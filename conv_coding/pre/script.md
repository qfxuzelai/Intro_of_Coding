# 提纲
大家好，我们是第6小组，下面开始我们的展示。我们的展示分为5个部分的内容，其中前3部分是具体模块的设计，第4部分是整体流程分析，最后1部分是针对具体传输任务的相应设计。

# 复数电平映射
首先是复数电平映射和判决模块，针对信道的2种场景我们设计了3种映射方法，分别称之为BMPSK, PHIMAP, 和ASK，我们会在后面解释其具体含义。下面是我设计的针对场景1的BMPSK映射方法。

# BMPSK—映射
首先是BMPSK的映射。

# 信道分析
我们先对场景1的信道进行初步的分析，这里采用了2bit每符号的MPSK格雷映射。从发端和收端的星座图中可以看出：经过信道后，复数电平的相对相位信息得以保留，也就是说发端各电平之间的夹角是90度，到了收端大概也是90度；但是复数电平的绝对相位信息遭到丢失，这是说仅从收端我们没有办法判断哪一块对应的是00，这本质上是由MPSK的旋转对称性造成的。

# 电平设计
基于上述分析我们就引入了BMPSK的电平设计。其实对于这个信道最关键的设计就是如何估计\phi，既然MPSK的旋转对称性导致绝对相位信息丢失，那我们就想办法破坏它的旋转对称性，从而把\phi估计出来。这里我们采用的方法是引入一个直流偏置，从星座图上看就是把MPSK的电平整体向实数轴正方向移动了一段距离，我们用一个参数bias_ratio来刻画它的偏移程度。有了这样一个偏置过后，收发端电平就不再关于原点旋转对称了，因此我们可以在收端设计方法把\phi估计出来。

# BMPSK—判决
接下来就是BMPSK的判决

# 相位估计
首先是\phi的估计。我们的估计方法是基于如下几个观察：第1个式子是说发端各电平的中心是这个偏置圆的圆心，而偏置圆的圆心就是A·bias_ratio;第2个式子是说收端各电平的中心也是一个圆的圆心，这个圆心就是原来偏置圆的圆心转了角度\phi;那么利用第2个式子，我们就可以反解出\phi，因为实际不可能知道y的期望，所以我们用y的均值代替，这就是第3个式子;有了对\phi的估计后，我们就可以把y转回来然后搬回原点，这就可以等效为MPSK经过一个高斯信道后的情况，从而便于之后的判决。

# 判据推导
后面的判决其实和标准的MPSK是一样的，这里不花时间多讲。结论就是利用最大似然判决 等价于 利用欧氏距离判决 等价于 利用角度判决，所以我们在实现的时候可以很方便地对y求一个辐角，从而实现符号的判决。

# 仿真结果
然后就是我们的仿真结果。左边是线性坐标的误码率-信噪比曲线，右边是对数坐标的曲线。从左边的图可以看到，在相同信噪比的情况下，1bit的误码率小于2bit小于3bit，这个结果是合理的，因为比特数越多意味着我们在单位圆上放的电平就越多，也就导致我们对不同电平的区分能力下降，误码率自然就上升。而从右边的图可以看到，1bit映射的误码率在信噪比为10dB的时候降到10^-6，2bit大概在15db，3bit大概在20dB。

# BMPSK—折衷
第3部分是BMPSK设计中的一个trade-off。我们在前面使用了bias_ratio这样一个参数来刻画偏移的程度，那么这样一个参数对我们的映射到底有什么影响呢？我们可以先进行定性的分析

# 定性分析-1
第1个观察是bias_ratio越大，相位估计越准。这是因为bias_ratio越大，意味着我的偏置圆心模长越大，也就意味着它的抗噪声能力更强，所以相位就估计得越准。仿真结果也验证了我们的这个观察，因此从相位估计的角度而言，我们希望bias_ratio越大越好。

# 定性分析-2
第2个观察是bias_ratio越小，信号功率越小。这很显然，因为引入直流偏置自然会消耗更多的能量。我们可以推导出信号功率P正比于1+bias_ratio^2，去一个对数后近似为一个线性增长的关系。因此从信号功率的角度而言，我们希望bias_ratio越小越好。

# 仿真结果
既然从不同的角度出发对bias_ratio提出了不同的要求，我们就需要进行折衷。在仿真中我们分别取bias_ratio为1/16, 1/4, 1，得到了如下的结果。其中红线是1/16的结果，我们可以看到它有非常明显的抖动，这是因为它估\phi有的时候估得准，有的时候估不准，也就是说方差比较大，鲁棒性不够强；而蓝线是bias_ratio为1的结果，可以看到在相同误码率下，它需要的信号功率比1/4的绿线更高，因此综合分析，折衷的1/4是一个比较合理的参数值。经过多次仿真，我们最后确定bias_ratio的取值在1/8到1/4之间能有比较好的效果。

# 卷积码编解码
第2部分是卷积码的编解码，包括编码、硬判决译码、和软判决译码

# 卷积码编码
首先是卷积码的编码，这部分很简单不多讲，就是调用一下matlab的conv函数；这里我们先统一按照收尾处理，不收尾的话直接去掉最后4位码字就好。

# 硬判决译码
然后是硬判决译码

# 硬判决译码实现
这个其实也比较简单，具体的实现步骤如下：先是初始化一些基本的变量；然后进入循环译码，每次读取若干个码字计算单步的汉明距离，然后将单步汉明距离与累加汉明距离相加，选取各状态的最短路径更新累加汉明距离，最后记录幸存路径，这里实际上是通过记录当前状态的源状态来实现记录幸存路径。最后通过回溯就能实现viterbi译码。

# 软判决译码
然后是软判决译码

# 软判决译码实现
当我们是1/2效率+1bit或2bit映射，或者1/3效率+1bit或2bit映射的时候，软判决其实和硬判决没有什么区别，只不过我们的距离量度从码字间的汉明距离变成了电平间的欧氏距离。事实上我们可以使用任何一种距离量度来实现软判决译码，这也保证了我们程序的可移植性。

# 软判决译码推广-1
但是如果是1/2效率+3bit映射，或者1/3效率+2bit映射的情况，事情就没那么简单。我们以1/3效率+2bit映射为例，因为单步状态转移译出的码字是3个，而1个电平对应2个码字，因此我们不能实现单步状态转移和电平之间的简单对应。事实上我们可以发现，发生2步状态转移的时候，对应的码字是6个，我们可以读取3个电平，它们对应的码字也是6个，这样我们就可以将2步状态转移和3个电平对应起来。事实上，我们可以将这样的多步转移等效为一个单步转移，只不过它可能的转移路径不是8个，而是16个，有了这样一个等效过后，我们就可以用之前单步软判决算法结构来实现多步的软判决译码。

# 软判决译码推广-2
